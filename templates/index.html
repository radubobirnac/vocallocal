<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocalLocal - Speech to Text</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 20px 0;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        .logo {
            font-size: 2.5rem;
            font-weight: bold;
            color: #4e5afc;
        }
        .subtitle {
            color: #666;
            margin-top: 0.5rem;
        }
        .recorder-container {
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }
        #recordButton {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background-color: #4e5afc;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }
        #recordButton:hover {
            background-color: #3949db;
            transform: scale(1.05);
        }
        #recordButton i {
            font-size: 2rem;
        }
        #recordButton.recording {
            animation: pulse 1.5s infinite;
            background-color: #dc3545;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .language-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #transcript {
            min-height: 200px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            padding: 1rem;
            background-color: #f8f9fa;
            height: 100%;
        }
        #uploadForm {
            margin-top: 1rem;
        }
        .about-section i {
            transition: transform 0.3s ease;
        }
        .about-section button[aria-expanded="true"] i {
            transform: rotate(180deg);
        }
        .model-toggle {
            margin-bottom: 0.75rem;
        }
        .model-toggle h6 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        .model-toggle .form-check {
            margin-right: 1.5rem;
        }
        .info-icon {
            cursor: pointer;
            color: #4e5afc;
            margin-left: 5px;
        }
        .section-divider {
            height: 2px;
            background-color: #e9ecef;
            margin: 2rem 0;
        }
        
        /* Responsive adjustments */
        @media (min-width: 992px) {
            .transcript-container {
                height: 100%;
                display: flex;
                flex-direction: column;
            }
            .transcript-card-body {
                display: flex;
                flex: 1;
            }
            .controls-column {
                padding-right: 2rem;
                border-right: 1px solid #e2e8f0;
            }
        }
        
        @media (max-width: 991px) {
            .controls-column {
                margin-bottom: 2rem;
                padding-bottom: 2rem;
                border-bottom: 1px solid #e2e8f0;
            }
        }
        
        /* Tighter spacing for card elements */
        .card-body {
            padding: 1rem;
        }
        
        /* Reduce spacing around transcript heading */
        h6.transcript-heading {
            margin-bottom: 0.5rem;
            margin-top: 0.5rem;
        }
        
        /* Make dividers between sections thinner */
        .controls-column {
            padding-bottom: 0.75rem;
        }
        
        /* Reduce space between status and button */
        #recordingStatus {
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo-container">
                <div class="logo">VocalLocal</div>
                <p class="subtitle">Accurate Multilingual Speech-to-Text Transcription</p>
            </div>
            <div class="language-selector">
                <img src="https://img.icons8.com/ios-filled/24/000000/language.png" alt="Language" style="width: 24px; height: 24px;" />
                <label for="languageSelect" class="language-label"><i class="fas fa-globe"></i></label>
                <select id="languageSelect" class="form-select form-select-sm" style="width: auto;"></select>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Voice Transcription</h5>
                <button id="copyButton" class="btn btn-sm btn-outline-secondary">Copy</button>
            </div>
            <div class="card-body transcript-card-body p-2">
                <div class="row h-100">
                    <div class="col-lg-4 controls-column pb-2">
                        <div class="model-toggle mb-2">
                            <h6 class="mb-1">Model Selection</h6>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="radio" name="transcriptionModel" id="fastModel" value="gpt-4o-mini-transcribe" checked>
                                <label class="form-check-label" for="fastModel">Fast model</label>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="radio" name="transcriptionModel" id="accurateModel" value="gpt-4o-transcribe">
                                <label class="form-check-label" for="accurateModel">More accurate but slower</label>
                            </div>
                        </div>
                        
                        <div class="recorder-container">
                            <button id="recordButton">
                                <i class="fas fa-microphone"></i>
                            </button>
                            <div id="recordingStatus">Click to start recording</div>
                        </div>
                    </div>
                    
                    <div class="col-lg-8 transcript-container">
                        <h6 class="transcript-heading">Transcript</h6>
                        <div id="transcript" class="flex-grow-1">Transcribed text will appear here...</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section-divider"></div>

        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Upload Audio File</h5>
            </div>
            <div class="card-body">
                <form id="uploadForm" enctype="multipart/form-data">
                    <div class="mb-3">
                        <input class="form-control" type="file" id="audioFile" accept=".wav, .mp3, .ogg, .m4a, .mp4">
                    </div>
                    <div class="mb-3">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="uploadTranscriptionModel" id="uploadFastModel" value="gpt-4o-mini-transcribe" checked>
                            <label class="form-check-label" for="uploadFastModel">Fast model</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="uploadTranscriptionModel" id="uploadAccurateModel" value="gpt-4o-transcribe">
                            <label class="form-check-label" for="uploadAccurateModel">More accurate but slower</label>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary">Transcribe</button>
                </form>
            </div>
        </div>

        <div class="section-divider"></div>

        <div class="card mb-4">
            <div class="card-header">
                <button class="btn btn-link text-decoration-none p-0 w-100 text-start d-flex justify-content-between align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#aboutSection" aria-expanded="false" aria-controls="aboutSection">
                    <h5 class="mb-0">About VocalLocal</h5>
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>
            <div class="collapse" id="aboutSection">
                <div class="card-body">
                    <p>VocalLocal is a multilingual speech-to-text transcription tool designed to provide accurate transcriptions in multiple languages. Using advanced AI technology, it converts spoken language from audio recordings or microphone input into written text.</p>
                    
                    <h6>Features</h6>
                    <ul>
                        <li>Real-time transcription - Record directly from your microphone and get immediate results</li>
                        <li>File upload support - Process pre-recorded audio files in various formats</li>
                        <li>Multilingual capabilities - Support for 30+ languages with native language names</li>
                        <li>Easy copying - One-click copying of transcription results</li>
                    </ul>
                    
                    <h6>Limitations</h6>
                    <ul>
                        <li>Audio quality significantly affects transcription accuracy</li>
                        <li>Background noise may impact results</li>
                        <li>Maximum file size of 16MB per upload</li>
                        <li>Some rare languages or dialects may have lower accuracy. For more information on speech recognition accuracy measurements, see <a href="https://openai.com/index/introducing-our-next-generation-audio-models/" target="_blank">OpenAI's research on word error rates</a>.</li>
                        <li>Recordings are limited to 5 minutes maximum duration</li>
                        <li>Speaking in multiple languages at once may result in mixed results</li>
                    </ul>
                    
                    <h6>Technical Details</h6>
                    <p>VocalLocal uses OpenAI's speech recognition models to process audio. The application supports various audio formats including WAV, MP3, OGG, and M4A. The language detection feature can automatically identify the spoken language, though manually selecting the correct language may improve accuracy for certain languages.</p>
                    
                    <h6>Privacy Information</h6>
                    <p>Audio data is processed securely and is not stored permanently. Recordings are only kept temporarily during the transcription process and are deleted immediately afterward. Transcribed text remains in your browser and is not saved on our servers unless explicitly requested.</p>
                </div>
            </div>
        </div>

        <div class="mt-3">
            <div id="status" class="alert alert-info d-none"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://kit.fontawesome.com/4b1c7a602f.js" crossorigin="anonymous"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
            
            // Status message display
            function showStatus(message, type) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `alert alert-${type}`;
                statusEl.classList.remove('d-none');
                
                // Auto hide after 5 seconds
                setTimeout(() => {
                    statusEl.classList.add('d-none');
                }, 5000);
            }
            
            // Load languages
            const languageSelect = document.getElementById('languageSelect');
            const languages = {
                "English": "en",
                "Spanish": "es",
                "French": "fr",
                "German": "de",
                "Italian": "it",
                "Portuguese": "pt",
                "Dutch": "nl",
                "Japanese": "ja",
                "Chinese": "zh",
                "Korean": "ko",
                "Russian": "ru",
                "Arabic": "ar",
                "Hindi": "hi",
                "Turkish": "tr",
                "Swedish": "sv",
                "Polish": "pl",
                "Norwegian": "no",
                "Finnish": "fi",
                "Danish": "da",
                "Ukrainian": "uk",
                "Czech": "cs",
                "Romanian": "ro",
                "Hungarian": "hu",
                "Greek": "el",
                "Hebrew": "he",
                "Thai": "th",
                "Vietnamese": "vi",
                "Indonesian": "id",
                "Malay": "ms",
                "Bulgarian": "bg"
            };
            
            Object.entries(languages).forEach(([name, code]) => {
                const option = document.createElement('option');
                option.value = code;
                option.textContent = name;
                if (code === 'en') option.selected = true;
                languageSelect.appendChild(option);
            });
            
            // Upload form handling
            const uploadForm = document.getElementById('uploadForm');
            uploadForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const fileInput = document.getElementById('audioFile');
                if (!fileInput.files.length) {
                    showStatus('Please select a file', 'warning');
                    return;
                }

                const file = fileInput.files[0];
                // Log file information
                console.log("File info:", {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    lastModified: new Date(file.lastModified)
                });
                
                if (file.size > 16 * 1024 * 1024) {
                    showStatus('File size exceeds the maximum limit of 16MB', 'warning');
                    return;
                }

                const formData = new FormData();
                formData.append('file', file);
                formData.append('language', document.getElementById('languageSelect').value);
                formData.append('model', document.querySelector('input[name="uploadTranscriptionModel"]:checked').value);

                showStatus('Transcribing your audio...', 'info');
                
                try {
                    const response = await fetch('/api/transcribe', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        document.getElementById('transcript').textContent = result.text;
                        showStatus('Transcription complete!', 'success');
                    } else {
                        console.error("Transcription error:", result);
                        let errorMessage = result.error || 'Unknown error occurred';
                        if (result.errorType) {
                            errorMessage = `${result.errorType}: ${errorMessage}`;
                        }
                        showStatus(`Error: ${errorMessage}`, 'danger');
                    }
                } catch (error) {
                    console.error('Full error details:', error);
                    showStatus(`Network error: ${error.message}. Please check your connection and try again.`, 'danger');
                }
            });

            // Copy button
            document.getElementById('copyButton').addEventListener('click', () => {
                const text = document.getElementById('transcript').textContent;
                navigator.clipboard.writeText(text)
                    .then(() => showStatus('Copied to clipboard!', 'success'))
                    .catch(err => showStatus('Failed to copy: ' + err, 'danger'));
            });

            // Record button functionality
            const recordButton = document.getElementById('recordButton');
            const recordingStatus = document.getElementById('recordingStatus');
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;
            
            recordButton.addEventListener('click', async () => {
                if (isRecording) {
                    // Stop recording
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                    }
                    isRecording = false;
                    recordButton.classList.remove('recording');
                    recordingStatus.textContent = 'Processing...';
                    return;
                }
                
                // Start new recording
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Set up recorder
                    audioChunks = [];
                    const options = {};
                    
                    // Try to use better codecs if available
                    const mimeTypes = [
                        'audio/webm;codecs=opus',
                        'audio/webm',
                        'audio/mp4',
                        'audio/ogg;codecs=opus',
                        'audio/ogg'
                    ];
                    
                    let mimeType = '';
                    for (const type of mimeTypes) {
                        if (MediaRecorder.isTypeSupported(type)) {
                            mimeType = type;
                            break;
                        }
                    }
                    
                    if (mimeType) {
                        options.mimeType = mimeType;
                    }
                    
                    mediaRecorder = new MediaRecorder(stream, options);
                    
                    // Set up recording
                    isRecording = true;
                    recordButton.classList.add('recording');
                    recordingStatus.textContent = 'Recording... Click to stop';
                    
                    // Handle data as it becomes available
                    mediaRecorder.addEventListener('dataavailable', event => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    });
                    
                    // Handle recording stop
                    mediaRecorder.addEventListener('stop', () => {
                        // Stop all audio tracks
                        stream.getAudioTracks().forEach(track => track.stop());
                        
                        // Create audio blob
                        const mimeType = mediaRecorder.mimeType;
                        let fileType, fileName;
                        
                        // Detect iOS for compatibility
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                        
                        if (mimeType.includes('webm')) {
                            fileType = 'audio/webm';
                            fileName = 'recording.webm';
                        } else if (mimeType.includes('ogg')) {
                            fileType = 'audio/ogg';
                            fileName = 'recording.ogg';
                        } else {
                            // Default to m4a for iOS compatibility
                            fileName = isIOS ? 'recording.m4a' : 'recording.mp3';
                            fileType = isIOS ? 'audio/mp4' : 'audio/mpeg';
                        }
                        
                        const audioBlob = new Blob(audioChunks, { type: fileType });
                        const audioFile = new File([audioBlob], fileName, { type: fileType });
                        
                        // Log info for debugging
                        console.log("Recording format:", mimeType || "unknown");
                        console.log("File type:", fileType);
                        console.log("Blob size:", audioBlob.size, "bytes");
                        
                        // Create form data and add file
                        const formData = new FormData();
                        formData.append('file', audioFile);
                        formData.append('language', document.getElementById('languageSelect').value);
                        formData.append('model', document.querySelector('input[name="transcriptionModel"]:checked').value);
                        
                        // Show transcribing status
                        showStatus('Transcribing your recording...', 'info');
                        
                        // Send to server
                        fetch('/api/transcribe', {
                            method: 'POST',
                            body: formData
                        })
                        .then(response => {
                            console.log("Server response status:", response.status);
                            return response.json();
                        })
                        .then(result => {
                            console.log("Server response:", result);
                            if (result.text) {
                                document.getElementById('transcript').textContent = result.text;
                                showStatus('Transcription complete!', 'success');
                            } else {
                                showStatus('Transcription failed. Please try again.', 'danger');
                            }
                        })
                        .catch(error => {
                            console.error('Full error details:', error);
                            showStatus(`Error: ${error.message}`, 'danger');
                        });
                        
                        // Reset UI
                        recordButton.classList.remove('recording');
                        recordingStatus.textContent = 'Click to start recording';
                    });
                    
                    // Start recording with timeslice to get data
                    mediaRecorder.start(1000);  // Get a dataavailable event every second
                    
                } catch (error) {
                    recordButton.classList.remove('recording');
                    isRecording = false;
                    recordingStatus.textContent = 'Click to start recording';
                    
                    if (error.name === 'NotAllowedError') {
                        showStatus('Microphone access denied', 'warning');
                    } else {
                        showStatus(`Recording error: ${error.message}`, 'danger');
                    }
                    console.error('Error accessing microphone:', error);
                }
            });
        });
    </script>
</body>
</html>
